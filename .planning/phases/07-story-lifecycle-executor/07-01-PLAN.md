---
phase: 07-story-lifecycle-executor
plan: 01
type: tdd
domain: go
---

<objective>
Add status update capability to the status package for writing story status changes to sprint-status.yaml.

Purpose: Enable the lifecycle executor to update story status after each workflow step completes.
Output: Working, tested UpdateStatus function in internal/status package.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-lifecycle-definition/06-01-SUMMARY.md

# Key files (from Phase 6 frontmatter):

@internal/status/reader.go
@internal/status/types.go

**Tech stack available:** Go, yaml.v3, testify
**Established patterns:** Interface-based design, table-driven tests, co-located test files
**Constraining decisions:**

- Phase 6: LifecycleStep uses status.Status type for type safety
- v1.0: sprint-status.yaml was read-only, v1.1 adds write capability
  </context>

<feature>
  <name>Status Writer - UpdateStatus function</name>
  <files>internal/status/writer.go, internal/status/writer_test.go</files>
  <behavior>
    UpdateStatus(storyKey string, newStatus Status) error

    Cases:
    - Valid story key + valid status → updates YAML file, returns nil
    - Story key not found → returns error "story not found: {key}"
    - Invalid status value → returns error (validate before write)
    - File read error → returns wrapped error
    - File write error → returns wrapped error

    The function should:
    1. Read existing sprint-status.yaml
    2. Validate story exists
    3. Validate new status is valid
    4. Update the status in memory
    5. Write back to file (preserve YAML structure/comments if possible)

  </behavior>
  <implementation>
    Create Writer struct mirroring Reader pattern:
    - NewWriter(basePath string) *Writer
    - UpdateStatus(storyKey string, newStatus Status) error

    Use yaml.v3 for read-modify-write cycle. The status package already uses yaml.v3.
    Keep the write atomic where possible (write to temp, rename).

  </implementation>
</feature>

<verification>
go test ./internal/status/... -v
</verification>

<success_criteria>

- Failing test written and committed (RED)
- Implementation passes test (GREEN)
- Refactor complete if needed
- All 2-3 commits present
- go test ./internal/status/... passes
  </success_criteria>

<output>
After completion, create `.planning/phases/07-story-lifecycle-executor/07-01-SUMMARY.md` with:
- RED: What test was written, why it failed
- GREEN: What implementation made it pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced
</output>
