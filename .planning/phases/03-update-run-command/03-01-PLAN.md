---
phase: 03-update-run-command
plan: 01
type: execute
---

<objective>
Update the `run` command to use status-based workflow routing instead of the hard-coded full development cycle.

Purpose: Transform `run` from executing all 4 workflows sequentially to running only the appropriate workflow based on story status from sprint-status.yaml.
Output: Modified `run` command that reads status and routes to correct workflow, with tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (from frontmatter):

@.planning/phases/01-sprint-status-reader/01-01-SUMMARY.md
@.planning/phases/02-workflow-router/02-01-SUMMARY.md

# Key files from prior phases:

@internal/status/reader.go
@internal/status/types.go
@internal/router/router.go

# Files to modify:

@internal/cli/run.go
@internal/cli/root.go
@internal/cli/cli_test.go

**Tech stack available:** gopkg.in/yaml.v3
**Established patterns:** table-driven-tests, switch-statement-routing, sentinel-errors

**Constraining decisions:**

- Phase 01: Used direct yaml.v3 instead of Viper for sprint-status.yaml parsing
- Phase 02: Package-level function instead of struct for router (pure mapping, no state)
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Update run command to use status-based routing</name>
  <files>internal/cli/run.go, internal/cli/root.go</files>
  <action>
Modify `run.go` to:
1. Create a status.Reader with current working directory as basePath (empty string to use cwd)
2. Call reader.GetStoryStatus(storyKey) to get the status
3. Call router.GetWorkflow(status) to get the workflow name
4. Handle error cases:
   - If status reader returns error: print error, return exit code 1
   - If router returns ErrStoryComplete: print "Story is already complete, no action needed", return exit code 0 (success, not error)
   - If router returns ErrUnknownStatus: print error with the status value, return exit code 1
5. Call app.Runner.RunSingle(ctx, workflowName, storyKey) instead of RunFullCycle
6. Update command description to reflect new behavior: "Run the appropriate workflow based on story status"

Add imports in run.go:

- "errors"
- "bmad-automate/internal/status"
- "bmad-automate/internal/router"

Update root.go's App struct to include StatusReader:

- Add StatusReader field: `StatusReader *status.Reader`
- Initialize in NewApp: `StatusReader: status.NewReader("")` (empty string = use cwd)

Update run.go to use app.StatusReader instead of creating Reader inline.

Do NOT add the StatusReader to the function signature of newRunCommand - access it via the app struct.
</action>
<verify>go build ./... passes without errors</verify>
<done>run command compiles and uses status reader + router</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for status-based routing</name>
  <files>internal/cli/run_test.go</files>
  <action>
Create run_test.go with table-driven tests covering:
1. Story with backlog status → runs create-story workflow
2. Story with ready-for-dev status → runs dev-story workflow
3. Story with in-progress status → runs dev-story workflow
4. Story with review status → runs code-review workflow
5. Story with done status → prints completion message, returns exit code 0
6. Story not found in sprint-status.yaml → returns exit code 1
7. Sprint-status.yaml file not found → returns exit code 1

Test setup pattern:

- Use t.TempDir() to create temp directory
- Create \_bmad-output/implementation-artifacts/sprint-status.yaml with test data
- Create App with StatusReader pointing to temp dir
- Use MockExecutor to capture which workflow prompt was executed
- Assert on workflow name or error output

Follow existing cli_test.go patterns for test structure and assertions.
Use testify/assert for assertions (already used in project).

Since RunSingle calls GetPrompt which needs config, the tests should use the existing test setup patterns from cli_test.go to create a valid test config with workflows defined.
</action>
<verify>go test ./internal/cli/... -run TestRun passes</verify>
<done>All 7 test cases pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./internal/cli/...` passes
- [ ] `just lint` passes (or golangci-lint run)
- [ ] Manual test: `run` command with a real sprint-status.yaml routes correctly (if available)
</verification>

<success_criteria>

- run command updated to use status-based routing
- All tests pass
- No lint errors
- Command help text updated
  </success_criteria>

<output>
After completion, create `.planning/phases/03-update-run-command/03-01-SUMMARY.md`
</output>
